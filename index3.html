<html>
<head>
<title>P2</title>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="http://d3js.org/topojson.v2.min.js"></script>
<script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>

<style>
#map{ 
  display: block;
  margin: auto;
  width: 100%;
}

html{
  font-family: sans-serif;
}
#yearSlider { 
  width: 1000px; 
}

#legendText { 
  text-anchor: middle; 
}

#button1{
  width: 5%;
  height: 5%;
  background-color: #4096F2;
  border-radius: 25px;
  border-style: none;
  color: white;
}

#button2{
  width: 5%;
  height: 5%;
  background-color: #EF3B2E;
  border-radius: 25px;
  border-style: none;
  color: white;
}
#info{
  float: right;
  display: inline;
}
#date{
  font-weight: bold;
  font-size: 20pt;
  padding: 0px 0px 0px 0px;
}

</style>
</head>
<body>


<div id="info">
</div>
<p id="date">
</p>
<svg id="map"></svg>
<input id="yearSlider" type="range" min="1960" max="2010" value="1960" oninput="show(buttonSelection, value)">

<br/>

<button type="button" id="button1" autofocus="TRUE" onclick="showImportMap(yearSlider.value)">Imports</button>
<button type="button" id="button2" onclick="showExportMap(yearSlider.value)">Exports</button>
<div id="slider">
</div>
<h2>To think about</h2>
<ul>
  <li> What kind of scale? </li>
  <li> Is there a difference between no data and zero imports/exports?</li>
  <li> Should the scale reflect the min/max number for that year, or the min/max number for the whole dataset?</li>
</ul>
<script>

var height = 500;
var mapWidth = 1000;
var width = 1200;

var map = d3.select("svg#map")
  .attr("width", width)
  .attr("height", height);

var projection = d3.geoRobinson();
var pathGenerator = d3.geoPath().projection(projection);

//color scales
// var importColorScale = ["#ffffff", "#E3EEF4", "#C6DDE8", "#AACCDD", "#8EBBD2", "#5599BB", "#71AAC6", "#3988B0", "#1C77A4", "#006699"];
// d3.scaleOrdinal().range(["#4DB6AC", "#48A7C8", "#2D8ED7", "#448AFF", "#22A3EA", "#00BCD4", "#01579b", "#0d4781"])
// var importColorScale = ["#ffffff", "#ECF5FE", "#C6E0FB", "#B3D5FA", "#A0CBF8", "#8DC0F7", "#79B6F6", "#66ABF4", "#53A1F3", "#4096F2"];

var importColorScale = ["#4096F2","#53A1F3","#66ABF4","#79B6F6","#8DC0F7","#A0CBF8","#B3D5FA", "#C6E0FB", "#ECF5FE", "#ffffff"];

var exportColorScale = ["#FFFFFF", "#FCDBD9", "#F9B8B3", "#F8A6A0", "#F6948D", "#F5827A", "#F47167", "#F25F54", "#F14D41", "#EF3B2E"];

//global scales, maps, and other stuff
var importScale, exportScale, buttonSelection, importMapping, exportMapping;

//get ready for sidebar gradient. code from: https://bl.ocks.org/mbostock/1086421
var gradient = map.append("defs")
.append("linearGradient")
  .attr("id", "gradient")
  .attr("x1", "50%")
  .attr("y1", "0%")
  .attr("x2", "50%")
  .attr("y2", "100%")
  .attr("spreadMethod", "pad");

gradient.append("stop")
  .attr("offset", "0%")
  .attr("stop-color", "#fff");

gradient.append("stop")
  .attr("id", "end")
  .attr("offset", "100%");

var gradientRect = map.append("rect")
    .attr("width", 30)
    .attr("height", 400)
    .attr("x", 1032)
    .attr("y", 48)
    .attr("stroke", "#888");

//labels that need to be refreshed every time a new button is clicked
var legendLabels = map.append("g");

//parse functions check every value and update the maximum for imports
var maxImports = 0;
var importArr = [];
var parseImports = function(row){
  row.ISO = Number(row.ISO);
  Object.values(row).forEach(function(value,index){
    if(index>1) {
      value = +Math.log(value);
      importArr.push(value);
      if(value>maxImports){ 
        maxImports = value; 
      }
    }
  })
  return row;
}

//and the same for exports
var maxExports = 0;
var exportArr = [];
var parseExports = function(row){
  row.ISO = Number(row.ISO);
  Object.values(row).forEach(function(value,index){
    if(index>1) {
      value = +Math.log(value);
      exportArr.push(value);
      if(value>maxExports){ maxExports = value; }
    }
  })
  return row;
}

d3.queue()
  .defer(d3.json, "world-110m.json")
  .defer(d3.csv, "imports.csv", parseImports)
  .defer(d3.csv, "exports.csv", parseExports)
  .await(function(error, rawCountries, rawImports, rawExports){

    importMap = d3.map(rawImports, function(country){ 
      return country.ISO; 
    });
    exportMap = d3.map(rawExports, function(country){ 
      return country.ISO; 
    });

    //scales are weird. What kind? What kind of min/max?
    //var impMax = d3.max(rawImports, function(d){ return d.yr1960; });
    importScale = d3.scaleOrdinal().domain(importArr).range(importColorScale);

    // var expMax = d3.max(rawExports, function(d){ return d.yr1960; });
    exportScale = d3.scaleOrdinal().domain(exportArr).range(exportColorScale);

    countries = topojson.feature(rawCountries, rawCountries.objects.countries);

    //initialize to imports in 1960.
    showImportMap(1960);
  });

//function for the slider to use that picks map to show based on import/export selection
function show(type, year){
  if (type=="imports"){ 
    showImportMap(year); 
  }
  if (type=="exports"){ showExportMap(year); }
}

function showImportMap(year){
  //set buttonselection to imports and yearinput to access csv variables
  buttonSelection = "imports";
  var yearInput = "yr" + year;

  projection.fitExtent([[0,0], [mapWidth, height]], countries);
	pathGenerator = d3.geoPath().projection(projection);

  //make and fill map
	var paths = map.selectAll("path").data(countries.features);
	paths.enter().append("path").attr("class", "country")
	.merge(paths)
  .attr("fill", function (country){
    var data = importMap.get(country.id);
    console.log(data)
    console.log(yearInput)
    if (data && yearInput != undefined && yearInput != null){ 
      return importScale(data[yearInput]); 
    } else {
      return "#888";
    }
  })
  .attr("stroke", "#888")
  .attr("d", function (country) {
    return pathGenerator(country);
  })
  .on("mouseover", function(country){
    var data = importMap.get(country.id);
    document.getElementById("info").innerHTML = "Country: " + data.Country + "<br>" + "Year: " + year + "<br>" + "Import: $" + Math.round(data[yearInput] * 100)/100 + " worth of arms.";

    console.log("In " + year + ", " + data.Country + " imported $" + Math.round(data[yearInput] * 100)/100 + " worth of arms.")
  })

  document.getElementById("date").innerHTML = year + " ";

  // .on("input", function(country){
  //   var data = importMap.get(country.id);
  //   document.getElementById("info").innerHTML = "Year: " + year + ".";

  //   console.log("In " + year + ". ")
  // });

  //remove old gradient color and add new one
  d3.select("#end").remove();
  gradient.append("stop")
    .attr("id", "end")
    .attr("offset", "100%")
    .attr("stop-color", "#4096F2");
  gradientRect.attr("fill", "url(#gradient)");


  //remove the previous legend info, otherwise it gets overwritten and obscured
  d3.select("#legendText").remove();
  legendLabels.append("text")
    .attr("id", "legendText")
    .attr("x", 1047)
    .attr("y", 40)
    .text("Imports");

}

function showExportMap(year){
  buttonSelection = "exports";
  var yearInput = 'yr' + year;
  projection.fitExtent([[0,0], [mapWidth, height]], countries);
	pathGenerator = d3.geoPath().projection(projection);

	var paths = map.selectAll("path").data(countries.features);
	paths.enter().append("path").attr("class", "country")
	.merge(paths)
  .attr("fill", function (country){
    var data = exportMap.get(country.id);
    if (data && yearInput != undefined && yearInput != null){ 
      return exportScale(data[yearInput]); 
    } else {
      return "#888";
    }
  })
  .attr("stroke", "#888")
  .attr("d", function (country) {
    return pathGenerator(country);
  })
  .on("click", function(country){
    var data = exportMap.get(country.id);
    document.getElementById("info").innerHTML = "Country: " + data.Country + "<br>" + "Year: " + year + "<br>" + "Import: $" + Math.round(data[yearInput] * 100)/100 + " worth of arms.";

    console.log("In " + year + ", " + data.Country + " exported $" + Math.round(data[yearInput] * 100)/100 + " worth of arms.")
  })

  document.getElementById("date").innerHTML = year + " ";
  
  d3.select("#end").remove();
  gradient.append("stop")
    .attr("id", "end")
    .attr("offset", "100%")
    .attr("stop-color", "#EF3B2E");
  gradientRect.attr("fill", "url(#gradient)");

  d3.select("#legendText").remove();
  legendLabels.append("text")
    .attr("id", "legendText")
    .attr("x", 1047)
    .attr("y", 40)
    .text("Exports");
}

function makeGraph(country){

}

</script>
</body>
</html>
